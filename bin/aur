#!/bin/bash

aurDir=~/aur
markerFile='.update_pulled.temp'
gitDirRegex='^.*/(.*).git$'

# Used during new install process
pkgDir=''

clean() {
    test -f $markerFile && rm $markerFile
    if ls | grep pkg.tar.zst > /dev/null ; then
        todelete=`ls *.pkg.tar.zst`

        echo -e "Found package files to clean...\n$todelete\n"
        read -p "Remove? [Y/n] " -n 1 response
        case "${response:0:1}" in
            n|N )
                return 1
            ;;
            * )
                rm $todelete
            ;;
        esac
    fi
}

clone() {
    git clone $1 || exit 1
    touch $markerFile
}

check_update() {
    # Returns 1 if there's no update
    gpout=`git pull`

    if [ -f "$markerFile" ]; then
        echo "Found temp file...continuing"
    elif [ "$gpout" == "Already up to date." ]; then
        return 1
    else
        echo $gpout
        touch $markerFile
    fi
    return 0
}

build() {
    read -p "Build? [Y/n/(e)xit] " -n 1 response
    case "${response:0:1}" in
        e|E )
            exit 0
        ;;
        n|N )
            return 1
        ;;
        y|Y|* )
            makepkg -s -c -C || return 1
        ;;
    esac
    return 0
}

install() {
    # Assumes working dir is a repo with a built package with a built package
    pkg=`ls *.pkg.tar.zst`
    
    if [ $( echo "$pkg" | wc -l ) -gt 1 ]; then
        read pkg <<< $(echo "$pkg" | smenu -d -m "Found multiple packages, choose install:" -s /N)
    elif [ -f "$pkg" ]; then
        echo "Found package '$pkg'"
    else
        echo "Package file not found"
        echo 1
    fi

    if sudo pacman -U $pkg ; then
        return 0
    else
        exit 1 # may want to return in the future but dump the install out for now
    fi
}

set_pkg_dir() {
    # arg 1 is the git remote url
    if [[ "$1" =~ $gitDirRegex ]]; then
        pkgDir="${BASH_REMATCH[1]}"
        return 0
    else
        echo "Couldn't parse for repo folder"
        exit 1
    fi
}

new_install() {
    # arg 1 is the git remote url
    cd $aurDir
    # Get the repo dir in $pkgDir
    set_pkg_dir $1
    # Clone the repo (ends up in that dir)
    clone $1
    # It's basically update_workdir $pkgDir from here.
    cd "$pkgDir"
    echo "Working directory '$PWD'"
    build || return 1
    install # needs to change if install returns 1
    clean
}

update_workdir() {
    check_update || return 0 # doesn't really matter what this is as long as it returns
    build || return 1
    install
    clean
}

update_dirname() {
    cd $aurDir
    if [ -d "$1" ]; then
        cd "$1"
        update_workdir
    else
        echo "Package dir '$1' not found"
        # Maybe return 1 instead to not drop out
        exit 1
    fi
}

update_all() {
    for dir in $aurDir/*; do
        echo "Checking '$(basename $dir)'..."
        # Passing the full dir to update_dirname() defeats
        # what it does but that is fine.
        update_dirname $dir
    done
}

remove_dirname() {
    cd $aurDir
    if [ -d "$1" ]; then
        rm -rf "$1"
        echo "Deleted '$aurDir/$1'"
    else
        echo "Package dir '$1' not found"
    fi
    if sudo pacman -Rs $1; then
        return 0
    else
        return 1
    fi
}

# arg 1 is '-<command char>'
case "${1:1:2}" in
    i )
        new_install $2
    ;;
    u )
        update_dirname $2
    ;;
    a )
        update_all
    ;;
    r )
        remove_dirname $2
    ;;
    h )
        echo -e 'Usage: aur [option] [TARGET]'

        echo -e '  -i      install package from TARGET git repo url\n'
        echo -e '  -u      update package TARGET\n'
        echo -e '  -a      update all packages\n'
        echo -e '  -r      remove package TARGET'
        echo -e '          attempts to remove depencencies with pacman -Rs\n'
        echo -e '  -l      list downloaded packages\n'
    ;;
    l|* )
        ls -1 $aurDir
    ;;
esac

